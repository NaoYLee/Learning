# Linux

## 版本

**社区版**：开源免费版本  
kernel内核

**发行版**：内核及各常用软件的集合 , 由不同的公司发行商业版本  
​Redhat 红帽  
​Ubuntu 乌班图  
​CentOS

​**个人桌面版**  
​拥有图形化界面 , 直观

​**企业服务器版**  
​稳定性好 , 资源消耗小

## Linux系统目录结构

| 目录 | 目录内容 |
| - | - |
| /bin | 二进制文件 |
| /sbin | 系统二进制文件 |
| **/etc** | **配置文件** |
| /dev | 设备文件 |
| /proc | 进程信息 |
| /var | 可变数据 |
| /tmp | 临时文件 |
| /**usr** | **用户程序** |
| /**home** | **用户主目录** |
| /root | root用户主目录 |
| /boot | 启动文件 |
| /lib | 库文件 |
| /opt | 可选文件 |
| /mnt | 临时挂载点 |
| /media | 可移动媒体 |
| /srv | 服务文件 |
| /run | 运行数据 |

## 操作命令

### Linux命令的组成

`[COMMAND]+[OPTIONS]`

`[COMMAND]`是预设好的二进制可执行程序

`[OPTIONS]`命令参数,只区分大小写,不区分顺序

多用tab键

`./` 当前目录  
`../` 上级目录  
`<./path>` 以当前目录为基础的<相对路径>  
`</path>` 从根目录开始的<绝对路径>
***

### `cd`

​切换工作目录

```shell
# 前往根目录
cd /

# 前往用户主目录
cd ~

# 前往上一个目录
cd -

# 前往上级目录
cd ..

# 前往上两级目录
cd ../..
```

***

### `pwd`

​查看当前工作目录
***

### `ls`

​查看目录及文件(忽略`.`开头隐藏文件)

```shell
# 展示当前路径文件及目录
ls

# 展示<绝对路径>下文件及目录
ls </path>

# 只展示<文件名>信息
ls <file>
```

| option | 功能 |
| - | - |
| `-a` | 不忽略`.`开头文件 |
| `-l` | 使用长列形式展示 |
| `-h` | 以人性化形式展示文件大小 |

***

### `touch`

创建文件

```shell
touch <file> 
```

***

### `mkdir`

​创建目录

```shell
# 在当前目录下创建目录
mkdir <dir>

# 依路径依次创建目录
mkdir -p </path/dir>
```

***

### `rmdir`

​删除目录

```shell
# 在当前目录下删除目录
rmdir <dir>
```

***

### `rm`

​删除文件或目录

```shell
# 在当前目录下删除文件
rm <file>
```

| option | 功能 |
| - | - |
| `-f` | 不做提醒强制删除文件或目录 |
| `-r` | 递归删除 |

***

### `cp`

​复制文件或目录

```shell
# 将<文件名>复制到<绝对路径>
cp [</path>/]<file> </path>

# 将<文件名>复制到<绝对路径>并重命名为<新文件名>
cp [</path>/]<file> </path/new_file>
```

| option | 功能 |
| - | - |
| `-f` | 覆盖目标路径已有同名文件 |
| `-i` | 覆盖目标路径已有同名文件前提示 |
| `-u` | 当源文件比目标路径同名文件更新时覆盖 |
| `-r` | 递归复制文件 |

如果最后一个命令参数为一个已经存在的目录名,`cp`会将每一个源文件复制到那个目录下(维持原文件名)。  
如果所给的参数只有两个文件名,它把前一个文件复制到后一个文件上。  
如果最后一个参数不是文件名、目录名、和给出多于两个非选项参数,是错误的。  

如果`/b`已经存在,`cp -r /a /b`会复制`/a`到`/b`而成为`/b/a`,复制`/a/x`到`/b`而成为`/b/a/x`。  
但如果`/b`事先不存在,它会把`/a`复制为`/b`,而复制`/a/x`到`/b`则成为`/b/x`。
***

### `mv`

​移动文件或目录

```shell
# 将<文件名>移动到<绝对路径>
mv [</path>/]<file> </path>

# 将<文件名>复制到<绝对路径>并重命名为<新文件名>
mv [</path>/]<file> </path/new_file>
```

| option | 功能 |
| - | - |
| `-f` | 覆盖目标路径已有同名文件 |
| `-n` | 不要覆盖目标路径已有同名文件 |
| `-i` | 覆盖目标路径已有同名文件前提示 |
| `-u` | 当源文件比目标路径同名文件更新时覆盖 |

***

### `vim`

​文本编辑器

#### 命令模式

| 定位命令 | 命令功能 |
| - | - |
| `$` | 移至光标所在行行尾 |
| `0` | 移至光标所在行行首 |
| `gg` | 移至首行行首 |
| `G` | 移至末行行首 |
| `nG` | 移至第n行行首 |

| 复制粘贴命令 | 命令功能 |
| - | - |
| `yy`/`Y` | 复制光标所在行 |
| `nyy`/`nY` | 复制光标所在行以下n行 |
| `P` | 粘贴至光标所在行之上 |
| `p` | 粘贴至光标所在行之下 |

| 替换撤销命令 | 命令功能 |
| - | - |
| `r` | 替换光标所在处字符 |
| `R` | 进入替换输入模式 |
| `u` | 撤销上一步操作 |

| 删除命令 | 命令功能 |
| - | - |
| `x` | 删除光标所在字符 |
| `nx` | 删除光标后n个字符 |
| `X` | 删除光标前字符 |
| `nX` | 删除光标前n个字符 |
| `dd` | 删除光标所在行 |
| `ndd` | 删除光标所在行以下n行 |

#### 插入模式

​**命令模式下使用插入命令进入插入模式**

| 插入命令 | 命令功能 |
| - | - |
| `i` | 在光标位置开始插入内容 |
| `a` | 从光标后一位开始插入内容 |
| `I` | 从光标所在行行首插入内容 |
| `A` | 从光标所在行行尾插入内容 |
| `o` | 在光标所在行下一行创建新行 |
| `O` | 在光标所在行上一行创建新行 |
| esc键 | 返回命令模式 |

#### 末行模式

​**命令模式下输入`:`进入末行模式**

| 末行命令 | 命令功能 |
| - | - |
| `:set nu` | 显示行号 |
| `:set nonu` | 取消显示行号 |
| `:n` | 移至第n行 |
| `:w` | 保存 |
| `:q` | 退出 |
| `:wq` | 保存并退出 |
| `:q!` | 强制退出 |
| `:wq!` | 强制保存并退出 |
| esc键 | 返回命令模式 |

***

### `cat`

```shell
# 查看<文件>全部内容
cat <file>
```

| option | 功能 |
| - | - |
| `-n` | 查看<文件>全部内容并显示行号 |

***

### `head`

```shell
# 查看<文件>前10行内容
head <file>

# 查看<文件名>前<数字>行内容
head -<n> <file>
```

| option | 功能 |
| - | - |
| `-<n>` | 查看<文件>前<数字>行内容 |

***

### `tail`

```shell
# 查看<文件>尾部10行内容
tail <file>
```

| option | 功能 |
| - | - |
| `-<n>` | 查看<文件>尾部<数字>行内容 |
| `-f` | 动态监控文件变化 |

***

### `echo`

```shell
# 在窗口上打印<文本内容>
echo '<text>'

# 将<文本内容>覆盖至<文件名>
echo '<text>' > <file>

# 将<文本内容>追加至<文件名>
echo '<text>' >> <file> -- 将<文本内容>追加至<文件名>

# 输出<指令>运行结果
echo `<command>`
```

***

### `more`

```shell
# 满屏幕展示<文件名>内容
more <file>
```

| 常用阅读操作 | 操作功能 |
| - | - |
| space键 | 展示下一屏 |
| entry键 | 展示下一行 |
| b | 展示上一屏 |
| q | 退出阅读 |
| h | 帮助界面 |

***

### `less`

![Static Badge](https://img.shields.io/badge/%E5%BE%85%E5%AE%8C%E5%96%84-red)

```shell
less [OPTIONS] <文件名> -- 上下分屏展示<文件名>内容
```

具体操作看-help吧
***

### `find`

​搭配 `*` 通配符使用搜索文件及目录

```shell
# 查找指定<文件类型>的文件
find -type -f
find -type -d

# 查找大于/小于<文件大小>的文件
find -size +/-<size>

# 查找文件名满足<表达式>的文件
find -name <expression>

# 文件在<数字表达式>天前被访问(读取)过
find -atime <n>

# 文件元数据在<数字表达式>天前被修改过
find -ctime <n>

# 文件在<数字表达式>天前被修改过
find -mtime <数字表达式> 
```

| 数字表达式 | 含义 | 示例 | 范围 |
| - | - | - | - |
| n | 准确\<n> | 1 | ==1 |
| +n | 严格大于\<n> | +1 | >=2 |
| -n | 不足\<n> | -1 | <1 |

***

### `chmod`

修改权限  
只有文件所有者(文件创建者)和最高权限用户可以修改权限

| 权限 | 文件 | 目录 |
| - | - | - |
| r | 读取指定文件数据 | 读取指定目录结构 |
| w | 编辑指定文件数据 | 新建、删除、移动指定目录下文件及目录 , 将文件及目录复制至指定目录 |
| x | 执行指定文件 | 进入指定目录 |

```txt
-rwxr-xr--
  7  5  4
第1位 文件类型：
- 文件 d 目录 l 链接
第2-4位 文件主用户 user:u
r 读 4 w 写 2 x 执行 1
-rwx------ 7
第5-7位 文件用户组 group：g
r 读 4 - 不可写 0  x 执行 1
----r-x--- 5
第8-19位 其他用户 other：o
r 读 4 - 不可写 0 - 不可执行 0
-------r-- 4
```

```shell
# 向<对象>增加针对<文件名/目录>的<权限类型>
chmod <对象> +<权限类型> [file|dir]

# 从<对象>删除针对<文件名/目录>的<权限类型>
chmod <对象> -<权限类型> [file|dir]

# 根据<权限数字值>向不同对象赋予针对<文件名/目录>的权限
chmod <权限数字值> [file|dir]

# 递归修改目录及以下文件权限
chmod -R 
```

***

### `su`

​切换用户

```shell
su <username>
```

***

### `date`

查看当前本地时间

```shell
-u  查看世界标准时
```

***

### `cal`

​查看当前日历

```shell
# 查看指定年份日历
cal -<year>
```

***

### `free`

​查看内存

```shell
# 以人性化形式展示
free -h
```

***

### `ln`

​建立链接

```shell
# 将<目标路径>链接至<文件路径>
ln </path> </target_path>

# 建立软连接
ln -s
```

| 连接方式 | |
| - | - |
| 软连接 | 类似Windows的快捷方式,包含目标文件的路径信息,访问<目标路径>时实际上是访问<文件路径>。<文件路径>被删除或移动后<目标路径>失效 |
| 硬链接 | <文件路径> <目标路径>享有相同的元数据inode,只有所有指向<文件路径>的链接被删除后文件才会失效 |

***

### `tar`

​打包

```shell
# 将<目标文件1> <目标文件2> ...打包为<文件名.tar>
tar <file.tar> <file_1> <file_2> ...

# 将<文件名.tar>解包到<目标路径>
tar <file.tar> -C </path>

# 创建新的备份文件
tar -c

# 从备份文件中还原
tar -x
-v 展示COMMAND执行过程
-f <文件名> 指定备份到<文件名>
-z 压缩/解压缩(搭配-c/-x使用)
```

压缩方式

![Static Badge](https://img.shields.io/badge/%E5%BE%85%E5%AE%8C%E5%96%84-red)

```shell
 .gz
```

***

### `which`

​查询Linux指令所在路径
***

### `grep`

```shell
grep [OPTIONS] <字符串> <文件路径> -- 在<文件路径>中查找<字符串>
```

```shell
-n 显示查询结果所在行号
```

***

### `wc`

​词频统计

```shell
wc [OPTIONS] <文件路径>
```

```shell
-c 输出字节大小
-m 输出字符数
-w 输出单词数(以空格分隔计算)
-l 输出行数
```

### `top`

​实时监控进程信息

```shell
-p 按CPU使用效率排序
-m 按内存使用率进行排序
```

使用 --sort 也可以进行排序

使用q键退出

### `ps`

​查看当前进程快照

UNIX标准格式输出

```shell
-ef 查看所有进程信息
-o <进程属性1> , <进程属性2> ,  .  .  .  以用户自定义形式展示进程信息
```

BSD格式输出

```shell
a 显示所有用户的进程
u 以用户友好的形式进行显示
x 显示无控制终端的进程
```

### `kill`

​结束进程

```shell
kill [OPTIONS] <PID> ,  .  .  .   -- 向多个进程发送信号
kill -<信号名> <PID>  -- 发送指定信号
```

```shell

```

| 信号编号 |  信号名   |          功能           |
| :------: | :-------: | :---------------------: |
|    1     | `SIGHUP`  |          挂起           |
|    2     |           |                         |
|    3     |           |                         |
|    9     | `SIGKILL` |        强制终止         |
|    15    | `SIGTREM` | 默认信号 , 进程正常退出 |
|    18    |           |                         |
|    19    |           |                         |
|          |           |                         |
|          |           |                         |

### `systemct1`

|          COMMAND           |      功能      |
| :------------------------: | :------------: |
|  systemctl start <服务名>  |    启动服务    |
|  systemctl  stop <服务名>  |    关闭服务    |
| systemctl status <服务名>  |  查看服务状态  |
| systemctl restart <服务名> |    重启服务    |
| systemctl enable <服务名>  | 开启开机自启动 |
| systemctl disable <服务名> | 关闭开机自启动 |

### 关机命令

#### `shutdown`

通知所有用户 , 阻止新用户登录

```shell
[sudo] shutdown -h now  -- 现在关机
[sudo] shutdown -h +10  -- 10分钟后关机
[sudo] shutdown -h 23:30  -- 23:30关机
[sudo] shutdown -c  -- 取消关机计划
```

#### `poweroff`

​ 关闭电源

### 常用Linux命令

 `tail -f`  实时监控文件变化
 `chmod`  权限管理
 `du`
 `wc`
 `free -h`  查看内存使用
 `df -h`  查看磁盘空间
 `sed`
 `awk`
 `grep`

## 文本处理

### 正则表达式

#### 基本元字符

| 元字符 | 说明 | 示例 |
| - | - | - |
| ` . ` | 匹配除换行符 `\n` 外的任意**单个**字符 | `gr.y` 匹配 `grey` `gray` |
| `*` | 量词:匹配其前面的字符出现 `[0,∞)` 次 | `go*d` 匹配 `gd` `god` `good` `gooooood` |
| `+` | 量词:匹配其前面的字符出现 `[1,∞)` 次 | `go+d` 匹配  `god` `good` `gooooooood` |
| `?` | 量词:匹配其前面的字符出现 `[0,1]` 次 | `colou?r` 匹配 `color` `colour` |
| `{n}` | 量词:匹配其前面的字符出现 `n` 次 | `go{2}d` 匹配 `good` |
| `{n,}` | 量词:匹配其前面的字符出现 `[n,∞)` 次 | `go{2,}d` 匹配 `good` `gooooood` |
| `{n,m}` | 量词:匹配其前面的字符出现 `[n,m]` 次 | `go{1,2}d` 匹配 `god` `good` |
| `^` | 锚点:匹配**行首**  | `^start` 匹配以**start**开头的行 |
| `$` | 锚点:匹配**行尾** | `end$` 匹配以**end**结尾的行 |
| `[ ]` | 字符集:匹配其中**任意**一个字符 | `gr[ae]y` 匹配 `gray` `grey` |
| `[^ ]` | 否定字符集:匹配非其中**任意**一个字符 | `[^0-9]` 匹配任意非数字字符 |
|  `[-]` | 范围表示 | `[a-z]` 匹配任意小写字母 , `[0-9]` 匹配任意数字 |
| `\` | 转义字符:将**元字符**转换为其**字面含义** , 或将**普通字符**转义为**特殊含义** | `\.` 匹配为 ` . ` ; `\*` 匹配为 `*` ;  `\d` 匹配为数字 |
| `()` | 分组:将多个字符组合为一个单元 | `(log)?` 匹配**log**或空字符串 `(ab)+` 匹配 `ab` `abab` |
| `\|` | 或 | `(ab)\|(xyz)` 匹配 `ab` 或 `xyz` |

##### 贪婪与非贪婪

```shell
abbbbbc
```

​ 量词会尽可能匹配更多字符 ,

​  `ab*` `ab+` 会匹配所有5个b

​ 在量词后加 `?` 可以使量词变为非贪婪模式 ,

​  `ab*?` 会匹配0个 `b`  ,  `ab+?` 会匹配1个 `b`

##### 常用字符

| 字符类 |                 说明                  |                 |
| :----: | :-----------------------------------: | :-------------: |
|  `\d`  |           匹配任意一个数字            |     `[0-9]`     |
|  `\D`  |        匹配任意一个非数字字符         |    `[^0-9]`     |
|  `\w`  |        匹配字母 , 数字或下划线        | `[a-zA-Z0-9_]`  |
|  `\W`  |       匹配非字母 , 数字和下划线       | `[^a-zA-Z0-9_]` |
|  `\s`  | 匹配任意空白字符(空格 , tab , 换行等) |                 |
|  `\S`  |          匹配任意非空白字符           |                 |

格式为 `$'string'` 的单词会被特殊处理。该单词会被展开（扩展）为 `string` 字符串，其中包含的反斜杠转义字符将按照 ANSI C 标准的规定进行替换。如果存在反斜杠转义序列，它们会被解码如下：

- **`\a`** 警报（响铃）
- **`\b`** 退格
- **`\e`**
- **`\E`** 一个转义字符（ESC）
- **`\f`** 换页符
- **`\n`** 换行符
- **`\r`** 回车符
- **`\t`** 水平制表符
- **`\v`** 垂直制表符
- **`\\`** 反斜杠
- **`\'`** 单引号
- **`\"`** 双引号
- **`\nnn`** 值为八进制数 `nnn` 所表示的 8 位字符（一到三位八进制数字）
- **`\xHH`** 值为十六进制数 `HH` 所表示的 8 位字符（一到两位十六进制数字）
- **`\uHHHH`** 值为十六进制数 `HHHH` 所表示的 Unicode (ISO/IEC 10646) 字符（一到四位十六进制数字）
- **`\UHHHHHHHH`**
    值为十六进制数 `HHHHHHHH` 所表示的 Unicode (ISO/IEC 10646) 字符（一到八位十六进制数字）
- **`\cx`** 一个 Control-x 字符（即 `Ctrl` 键加上 `x` 键对应的控制字符）

##### 正则表达式使用例

```shell
-- 大陆手机号
^1[3-9]\d{9}$
```

 `^1`  行首

 `1`  数字1

 `[3-9]`  3-9中任意一个数字

 `\d{9}`  任意9位数

 `$`  行尾

```shell
-- 银行卡号(16或19位)
^\d{16}(\d{3})?$
```

 `^`  行首

 `\d{16}`  匹配任意16位数

 `(\d{3})?`  匹配3位数或空字符串

 `$`  行尾

```shell
(ERROR|WARN)
```

()和|用于分组运行

|        逻辑运算符        |      |               功能               |
| :----------------------: | :--: | :------------------------------: |
|  <表达式1> && <表达式2>  |  与  | <表达式1>执行成功后执行<表达式2> |
| <表达式1> \|\| <表达式2> |  或  | <表达式1>执行失败则执行<表达式2> |

前一个表达式判断结果作为 `&&` `||` 判定是否执行的依据

##### `|`

​ 管道符 , 将<表达式1>输出的结果输入<表达式2>

```shell
<表达式1> | <表达式2>
```

##### ``

​ 反引号 , 避免命令被识别为字符

输入

```shell
echo 'pwd'
```

输出

```shell
pwd
```

##### `\`

​ 转义符 , 避免特殊字符被识别为COMMAND

### 文本处理三剑客

​ **对文件内容进行管理**

#### `grep`  Global Regular Expression Print

​ 主要用于**查找与过滤** .

​ 逐行读取输入 , 可以使用正则表达式搜索文本 , 打印匹配指定模式(pattern)的行

```shell
grep [OPTIONS] 'pattern' <文件名>
<前序命令> | grep [OPTIONS] 'pattern' -- 将从前序命令中获得的数据进行处理
```

```shell
-i 忽略大小写
-v 反向查找 , 只输出不匹配的行
-n 显示匹配行的行号
-c 只显示匹配行的行数
-w 精确匹配整个单词
-l 只显示包含匹配的文件名
-L 只显示不包含匹配的文件名
-r 递归搜索子目录 <文件名>改为<路径>
-E 使用扩展正则表达式
-o 只显示匹配到的字符串部分
-A <数字> 显示匹配行及其后<数字>行
-B <数字> 显示匹配行及其前<数字>行
-C <数字> 显示匹配行及其前后各<数字>行
```

​ **grep与正则表达式**

基本正则表达式 (Basic Regular Expressions ,  BRE): 默认模式 .  一些元字符 , 如： `?`  `+`   `{`   `|`   `(` 需要用反斜杠 `\` 转义后才具有特殊含义 .  

扩展正则表达式 (Extended Regular Expressions ,  ERE): 通过 `-E` 选项启用 . 元字符通常不需要反斜杠转义 , 语法更简洁 . 推荐学习和使用 ERE .  

#### `sed`  Stream Editor

​ 主要用于**编辑与转换** .

​ 流编辑器 , 对数据逐行处理 , 对匹配模式的行执行替换 , 删除 , 插入等操作

​ 适合对数据进行自动化\基于规则的修改

工作原理:

1 . 从输入读取一行文本

2 . 将文本存入内存缓冲区"模式空间"

3 . 按脚本命令顺序对内存中的文本进行处理

4 . 默认情况下 , 将处理后的文本打印至标准输出

```shell
sed [OPTIONS] '<脚本命令>' <文件名>
<前序命令> | sed [OPTIONS] '<脚本命令>' -- 将从前序命令中获得的数据进行处理
```

 `<脚本命令>` 由 `地址范围` `命令` 组成

`地址范围` 指定sed命令作用于哪些行

```shell
sed 'N<脚本>' <文件名> -- 只在第N行执行<脚本>
sed 'N , M<脚本>' <文件名> -- 只在第N行到第M行执行<脚本>
sed '<正则表达式> <脚本>' <文件名> -- 对满足正则表达式的内容执行<脚本>
sed '<起始正则表达式> , <结束正则表达式> <脚本>' <文件名> -- 从满足<起始正则表达式>的行到满足<结束正则表达式>的行之间执行<脚本>
```

```shell
-n 安静模式 , 只在脚本明确指示打印时'p'才输出结果
 sed -n '<脚本>p' <文件名>
-e 添加脚本 , 允许命令行使用多个脚本命令 , 也可以使用`;`分隔各脚本 
 sed -e '<脚本1>' -e '<脚本2>' <文件名>
 sed '<脚本1>';'<脚本2>' <文件名>
-f 从文件读取脚本
 sed -f <脚本文件> <文件名>
-E 使用扩展正则表达式
-i[ . SUFFIX] 极端危险 , 直接修改文件 , 极端危险 , 建议永远与备份后缀结合使用
 sed -i . bak '<脚本>' <文件名>
```

|          命令          |            功能            |
| :--------------------: | :------------------------: |
|     /`目标文本`/d      |    删除模式空间(当前行)    |
| s/`源文本`/`目标文本`/ |  用`目标文本`替换`源文本`  |
| y/`源字符`/`目标字符`/ | 用`目标字符`替换`源字符本` |
| a\\`目标文本`\ |在当前行下一行追加`目标文本` |
| i\\`目标文本`\  |在当前行上一行插入`目标文本` |
| c\\`目标文本`\ |用`目标文本`替换当前行|
|      /`<脚本>`/g       | 确保所有满足脚本的都被执行 |

#### `awk`  Aho , Weinberger , Kernighan

​ 主要用于格式化报告及按列处理 .

​ 将每行视作由若干字段组成 , 对字段进行提取 , 计算 , 比较 , 输出 .

```shell
awk [OPTIONS] 'program' <文件名>
<前序命令> | awk [OPTIONS] 'program' -- 将从前序命令中获得的数据进行处理
```

```shell
-F'<单字符>/<正则表达式>' 指定字段分隔符为<单字符>/<正则表达式>
```

 `program` 由一个或多个 `pattern { action }` 组成

 `pattern` :一个条件 , 用于决定 `action` 是否对当前记录执行 .  可以是正则表达式 , 比较表达式 ,  `BEGIN`  ,  `END` 等 . 如果省略 `pattern`  , 则 `action` 对所有行执行 .

```shell
awk -F' , ' '{程序内容}' <文件名>
awk -F' , ' 'BEGIN{程序内容}' <文件名>
awk -F' , ' 'END{程序内容}' <文件名>
awk -F' , ' '<正则表达式>{程序内容}' <文件名>
awk -F' , ' '<数值1> > <数值2>{程序内容}' <文件名>
```

 `action` :一组用花括号 `{}` 包裹的命令语句 , 在 `pattern` 匹配时执行 .  如果省略 `action`  , 则默认动作为 `print $0` (打印整行) .

 `$0` : 当前处理的整个记录(行)内容 .
 `$1`  ,  `$2`  ,   .  .  .    , `$N` : 第 1 ,  2 ,   .  .  .  ,  N 个字段的内容 .  
 `$NF` : 最后一个字段的内容 .
 `NF` : 当前记录的字段数量 .
 `NR` : 当前处理的总记录编号(行号) , 从 1 开始计数 .
 `FNR` : 当前文件中的记录数 (处理多文件时有用) .
 `FS` : 输入字段分隔符 .  默认为空格或 Tab .  可通过 -F 或 BEGIN { FS=" .  .  . " } 设置 .
 `OFS` : 输出字段分隔符 .  默认为一个空格 .  `print` 命令在输出多个字段(用逗号分隔)时会使用 OFS .  可通过 BEGIN { OFS=" .  .  . " } 设置 .
 `RS` : 输入记录分隔符 .  默认为换行符 \n .
 `ORS` : 输出记录分隔符 .  默认为换行符 \n .  `print` 命令执行后会自动添加 ORS .
 `FILENAME` : 当前正在处理的文件名 .  

## Shell

Linux 系统中的操作是通过 shell 指令调用内核进行的

### 解释器

解释器用于把 shell 指令翻译给系统内核

Linux 的 Shell 解释器种类众多，一个系统可以存在多个 shell，可以通过 `cat /etc/shells` 命令查看系统中安装的 shell

### 脚本

**Shell是大小写敏感的语言**  

编写第一个脚本

```shell
#!/bin/bash
echo "Hello,world!"
```

第一行的 `#!/bin/bash` 用于确定执行脚本的解释器

### 执行脚本

使用 `chmod` 给脚本增加执行权限

执行方式：

 `绝对路径/<脚本文件名>`

 `./<脚本文件名>`

### 变量

#### 定义变量

使用 `<变量名>=<值>` 来定义变量

```shell
name='liyizhi'
age='28'
address="Xi'an"
```

定义变量时需遵循以下规则

- `=` 两边不能有空格
- 首个字符必须为字母
- 变量名不允许出现空格及标点符号，可以使用 `_`
- 不能使用bash中的关键词

#### 只读变量

```shell
readonly <变量名>=<值>
```

#### 调用变量

**调用变量首先需要定义变量**  

调用定义过的变量需要在变量名前加 `$`

```shell
echo '我叫'$name'，今年'${age}'岁，住在'$address'。'
```

 `{}` 可选，便于识别变量边界

##### 删除变量

```shell
unset <变量名>
```

**只读变量不可删除**  

#### 局部变量

局部变量在脚本或命令中定义，**仅在当前 shell 实例中有效**，其他 shell 启动的程序不能访 问局部变量。

#### 全局变量

**所有的程序，包括shell启动的程序，都能访问环境变量**，有些程序需要环境变量来保证其正常运行。

可以用过 set 命令查看当前环境变量。

### 字符串

字符串是shell编程中最常用最有用的数据类型

#### 单引号

 `''`

示例：

```shell
skill='linux'
str='I am goot at $skill'
echo "$str"
```

输出结果:

```shell
I am goot at $skill 
```

单引号字符串的限制：

- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。
- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

#### 双引号

 `""`

示例：

```shell
skill='linux'
str='I am goot at ${skill}'
echo "$str"
```

输出结果:

```shell
I am goot at linux
```

双引号的优点：

- 双引号里可以有变量。
- 双引号里可以出现转义字符。

#### 获取字符长度

使用 `#`

```shell
skill='hadoop'

echo "${skill}" # 输出结果: hadoop

echo "${#skill}" # 输出结果: 6
```

#### 提取子字符串

使用`substring`

```shell
substring(2) # 从2开始截取到最后
substring(2,3) # 从2开始截取3个
```

```shell
skill='hadoop'
str="I am goot at $skill"
echo ${str:2} # 输出结果为: am goot at hadoop
echo ${str:2:2} # 输出结果为: am
```

注意：当字符串中有空格时，空格也算一个字符存在（字符串是从0开始计算）

### 参数传递

shell脚本的外部输入输入方式

在执行Shell程序脚本时，是可以向shell程序传递参数。

```shell
sh shellscript.sh # 启动运行解释器， 并把"shellscript.sh"作为参数传递过去
```

#### 参数传递方式

##### `$n`

```shell
./<脚本名> <参数1> <参数2> ...
```

shell程序脚本内获取参数的格式为：`$n`
 `n` 代表一个数字， `1` 为执行脚本的第一个参数， `2` 为执行脚本的第二个参数，以此类推……
 `$0` 表示当前脚本名称

|      |                                                           |
| :--: | :-------------------------------------------------------- |
|  $#  | 传递到脚本的参数个数                                      |
|  $*  | 以一个单字符串显示所有向脚本传递的参数                    |
|  $$  | 脚本运行的当前进程PID                                     |
|  $!  | 后台运行的最后一个进程的PID                               |
|  $@  | 与 `$*` 相同，但是使用时加引号，并在引号中返回参数        |
|  $?  | 显示最后命令的退出状态。0表示没有错误，其他值表示错误编号 |

```shell
#!/bin/bash
echo "第一个参数为： $1"
echo "参数个数为： $#"
echo "传递的参数作为一个字符串显示： $*"
```

输出结果为：

```plain
第一个参数为： 1
参数个数为： 3
传递的参数作为一个字符串显示： 1 2 3
```

###### $*和$@的区别

相同点： 都表示传递给脚本的所有参数。
不同点：

- 不被" "包含时：`$*` 和 `$@` 都以 `$1 $2… $n` 的形式组成参数列表
- 被" "包含时：
  - `"$*"` 会将所有的参数作为一个整体，以`$1 $2 … $n` 的形式组成一个整串
  - `"$@"` 会将各个参数分开，以 `$1` `$2` … `$n` 的形式组成一个参数列表

##### `read`

 使用 `read [参数] <变量名>` 由外部向<变量名>赋值

- `-p` 等待输入时显示 `"<提示信息>"`
- `-r` 用于防止输入文本中的 `\` 被视作转义符号
- `-t` 用于控制输入时间，以秒为单位
- `-s` 静默模式，输入内容不在终端上显示

### 参数列表 `{ }` 的用法

#### 大括号扩展（Brace Expansion）

用于快速生成序列或组合字符串，**在命令执行前展开**：

```shell
# 生成数字序列
echo {1..5}      # 输出: 1 2 3 4 5
echo {5..1}      # 输出: 5 4 3 2 1（倒序）
echo {1..10..2}  # 输出: 1 3 5 7 9（步长为2）

# 生成字母序列
echo {a..d}      # 输出: a b c d
echo {Z..A}      # 输出: Z Y X ... A（倒序）

# 组合字符串
echo {A,B,C}-file  # 输出: A-file B-file C-file
echo pre-{1..3}-post  # 输出: pre-1-post pre-2-post pre-3-post

# 嵌套组合
echo {A,B{1,2}}   # 输出: A B1 B2
```

#####

#### 参数扩展（Parameter Expansion）

用于操作变量值，语法为 `${变量名}`：

```shell
name="Alice"
echo ${name}      # 输出: Alice（基本用法）

# 设置默认值
echo ${unset_var:-"默认值"}  # 若变量未定义，输出"默认值"

# 截取子字符串
str="HelloWorld"
echo ${str:0:5}   # 输出: Hello（从索引0开始截取5字符）

# 替换内容
file="file.txt.bak"
echo ${file%.bak}    # 输出: file.txt（删除后缀）
echo ${file%%.*}     # 输出: file（贪婪删除后缀）
echo ${file#file.}   # 输出: txt.bak（删除前缀）
```

### 运算符

Shell和其他编程语言一样，支持包括：算术、关系、逻辑、字符串等运算符。
原生 /bin/bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如： `expr`
 `expr` 是一款表达式计算工具，使用它能完成表达式的求值操作。

#### 算术运算符

 `expr <计算式>`

- 表达式需要用反括号 `` 包裹
- 运算符号两边需要加空格

```shell
val_1=`expr 2 + 3`
echo "$val_1"
```

 **`$((<计算式>))`** 主要使用

 `$[计算式]`

```shell
val_2=$((2*3))
echo "$val_2"
val_3=$[5/3]
echo "$val_3"
```

| 运算符号 | 功能 |
| :------: | :--: |
|    +     |  加  |
|    -     |  减  |
|    *     |  乘  |
|    /     | 取整 |
|    %     | 取余 |

##### `i++` 与 `++i`

 `i++` ：先赋值，后+1

 `++i` ：先+1，后赋值

```shell
m=1
n=10
result_1="$((m++))"
result_2="$m"
result_3="$((++n))"
echo "$result_1"
echo "$result_2"
echo "$result_3"
```

结果如下

```plain
1
2
11
```

 `--` 计算逻辑相同

#### 关系运算符

关系运算符只能比较数字，或以字符串表示的数字

```shell
 >  >=  <  <=  !=  ==
```

| 运算符 |   含义   |
| :----: | :------: |
|  -eq   |   等于   |
|  -ne   |  不等于  |
|  -lt   |   小于   |
|  -gt   |   大于   |
|  -le   | 小于等于 |
|  -ge   | 大于等于 |

#### 逻辑运算符

| 运算符 | 含义 |
| :----: | :--: |
|   -a   |  和  |
|   -o   |  或  |

| 运算符 | 含义 |
| :----: | :--: |
|   &&   |  和  |
|  \|\|  |  或  |

区使用时需注意：

```shell
[ <判断语句1> ] && [ <判断语句2> ]
[ <判断语句1> -a <判断语句2> ]
```

#### 字符串运算符

| 运算符号  | 含义                     |
| :-------: | :----------------------- |
| -n STRING | 字符串长度不为零         |
| -z STRING | 字符串长度为零           |
|     =     | 判断两个字符串是否一样   |
|    !=     | 判断两个字符串是否不一样 |

#### 文件测试运算符

 `[运算符 <目标路径>]`

| 运算符号 | 含义                 |
| :------: | -------------------- |
|    -f    | 目标存在且是普通文件 |
|    -d    | 目标存在且是目录     |
|    -s    | 文件不为空           |
|    -e    | 文件存在             |
|    -r    | 文件存在并可读       |
|    -w    | 文件存在并可写       |
|    -x    | 文件存在并可执行     |

### 括号的用法区别

#### `( )`（圆括号）

**主要用途：**

- **子 Shell 执行**
    在子 Shell 中执行命令，**不影响父 Shell 环境**（如变量、目录）。

    ```shell
    (cd /tmp; ls)  # 在子 Shell 切换目录，父 Shell 目录不变
    ```

- **命令替换**
    使用 `$( )` 捕获命令输出（推荐替代反引号 `` ``）。

    ```shell
    files=$(ls)  # 将 ls 结果存入变量
    ```

- **定义数组**
    初始化数组元素。

    ```shell
    arr=("apple" "banana" "cherry")
    ```

#### `[ ]`（方括号）

**主要用途：**

- **条件测试**
    等同于 `test` 命令，用于文件/字符串/数值比较（**注意空格**）。

    ```shell
    if [ -f "file.txt" ]; then   # 检查文件是否存在
      echo "Found"
    fi
    
    if [ "$a" -eq 10 ]; then     # 数值比较
      echo "Equal"
    fi
    ```

- **通配符匹配**
    在文件名扩展中匹配单个字符（非正则表达式）。

    ```shell
    ls [abc]*  # 列出以 a/b/c 开头的文件
    ```

- **数组索引**
    访问数组元素。

    ```shell
    echo ${arr[1]}  # 输出 banana（索引从 0 开始）
    ```

#### `(( ))`（双圆括号）

**主要用途：**

- **整数算术运算**
    执行数学计算（无需 `$` 前缀变量）。

    ```shell
    ((result = 5 + 3 * 2))  # 计算 5+3*2
    echo $?                 # 输出上一条命令的退出状态（0表示成功）
    ```

- **逻辑/比较运算**
    支持 `>`, `==`, `&&`, `||` 等。

    ```shell
    if (( count > 10 && flag == 1 )); then
      echo "Valid"
    fi
    ```

- **自增/自减**
    简化变量操作。

    ```shell
    ((i++))  # i 自增 1
    ```

- **C 风格循环**
    用于 `for`/`while` 循环。

    ```shell
    for ((i=0; i<5; i++)); do
      echo $i
    done
    ```

#### `{ }`（花括号）

**主要用途：**

- **代码块分组**
    在当前 Shell 执行命令（**影响当前环境**）。

    ```shell
    { 
      cd ~/projects; 
      make 
    }  # 目录切换会影响当前 Shell
    ```

- **序列扩展**
    生成数字或字符序列。

    ```shell
    echo {1..5}     # 输出 1 2 3 4 5
    echo {a..c}.txt # 输出 a.txt b.txt c.txt
    ```

- **变量扩展**
    避免歧义或进行高级操作：

    ```shell
    echo ${var}_suffix  # 明确变量边界
    echo ${var:-default} # 若 var 未定义，使用 default
    echo ${var%.txt}    # 删除 .txt 后缀
    ```

- **组合命令**
    重定向整个代码块的输出。

    ```shell
    { date; ls; } > log.txt  # 将两条命令输出写入文件
    ```

- **创建匿名函数**
    结合 `()` 定义一次性函数。

    ```shell
    { func() { echo "Hello"; }; func; }  # 定义并调用
    ```

#### 核心区别总结

|  符号   |   作用域   |          典型用途          |    空格要求    |
| :-----: | :--------: | :------------------------: | :------------: |
|  `( )`  |  子 Shell  |  命令分组、数组、命令替换  | 内部命令需分隔 |
|  `[ ]`  | 测试表达式 |     条件判断、文件检查     | 括号内必须空格 |
| `(( ))` |  算术运算  |    数学计算、C 风格循环    |  内部无需 `$`  |
|  `{ }`  | 当前 Shell | 代码块、序列扩展、变量操作 | 首尾命令需分号 |

### 流程控制

默认执行流程：自上而下依次执行

```shell
#!/bin/bash # 第1行
num=100 # 第2行
((100++)) # 第3行
echo "$num" # 第4行
......
```

当希望改变程序的执行流程需要进行流程控制

- 条件语句：有选择性的执行某行或某段程序
  - `if...else`
  - `case`
- 循环语句：一直重复性的执行某行或某段程序，至到执行结束(条件控制循环执行的次数)
  - `for`
  - `while`

#### `if...else...`

##### 单支

```shell
if [ pattern ]
then
<program>
fi
```

根据 `[ pattern ]` 进行判断

- 返回结果为TRUE时执行 `<program>`

- 返回结果为FALSE时不进行后续操作

##### 双支

```shell
if [ pattern ]
then
<program_1>
else
<program_2>
fi
```

根据 `[ pattern ]` 进行判断

- 返回结果为TRUE时执行 `<program_1>`

- 返回结果为FALSE时执行 `<program_2>`

##### 多支

```shell
if [ pattern1 ]
then
<program_1>
elif [ pattern2 ]
then
<program_2>
......
else
<program_n>
fi
```

自上而下根据 `[ pattern ]` 进行判断，当返回结果为TRUE时执行对应的命令，忽略后续指令。

- 返回结果为FALSE时执行下一个 `elif` 语句
- 所有 `[ pattern ]` 均返回FALSE时执行 `<program_n>`

##### 使用 `&&` `||` 用于逻辑运算

 `&&` 两个pattern都返回true才执行 `<program>`

```shell
if [ pattern1 ] && [ pattern2 ]
then
<program>
fi
```

 `||` 两个pattern任一返回true就执行` <program> `

```shell
if [ pattern1 ] || [ pattern2 ]
then
<program>
fi
```

```shell
if [ true ] && [ false ]
then
echo "1"
fi
# 无结果输出
if [ true ] || [ false ]
then
echo "1"
fi
# 输出结果 1
```

#### `case`

使用 `case` 将变量进行匹配，执行满足条件的指令

```shell
case $<变量名> in
<pattern_1>)
<program_1>;;
<pattern_2>)
<program_2>;;
...
*) # 所有其他情况
<program_n>;;
esac
```

#### `for`

循环流程控制：程序在执行时重复性的执行某行或某段代码，不能出现死循环现象（在循环中添加条件用于在某个时刻结束循环）。

```shell
for((<初始值>;<循环条件>;<步长>))
do
<program>
done
```

```shell
for <变量名> in <指定参数列表>
do
<program>
done
```

#### `while`

```shell
while [expression]
do
<program>
done
```

 `<program>` 中必须有能够使 `[expression]` 不被满足的命令，避免死循环。

#### `until`

```shell
until [expression]
do
<program>
done
```

 `<program>` 中必须有能够使 `[expression]` 被满足的命令，避免死循环。

### 函数

#### 定义函数

 `function <函数名()>{ <program> }`

定义函数要在代码最顶端

#### 调用函数

当函数中使用了 `$n` 的方式从外部获取参数时，在调用函数时也要输入参数

先调用函数，再将参数传递到函数定义中，最终输出结果

#### `return`

```shell
#!/bin/bash
# 定义函数
function compare() {
    if [ "$1" -lt "$2" ]
    then
     # 使用return返回数据
     return "$2"
    else 
     return "$1"
    fi
}

# 调用函数
compare "$1" "$2"

# 使用$?获得return的返回值
echo "$?大"
```

使用 `return` 时需要利用 `$?` 获取函数的返回值

在 Shell 脚本中，`return` 命令用于函数退出时返回一个**整数值**，该值必须严格限制在 `0` 到 `255` 的范围内（8 位无符号整数）。这是由 Shell 的退出状态码规范决定的。

### 数组

数组可以理解为是一个用来存放多个值的容器。

数组中存储的数据，通常可以称为：元素。

当数组中存储了多个元素后，就会给每一个元素添加一个编号(索引)，从0开始。

#### 定义数组

Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小。

Shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：

```shell
<array_name>=(<value1> <value2> <value3> ... <valueN>)
```

也可以使用索引来定义数组：

```shell
# <array_name>[index]=<value>
my_array[0]=A
my_array[1]=B
```

#### 读取数组

读取数组中元素的一般格式是： `${<array_name>[index]}`

使用 `*` 或 `@` 可以获得数组中所有元素

```shell
#!/bin/bash
my_array=(A B)
echo "${my_array[1]}"
echo "${my_array[*]}"
echo "${my_array[@]}"
```

输出结果为

```shell
B
A B
A B
```

#### 获取数组长度

获取数组长度的方法与获取字符串长度的方法相同，使用 `#`

```shell
#!/bin/bash
my_array[0]=A
my_array[1]=B
echo "${#my_array[*]}"
echo "${#my_array[@]}"
```

输出结果为

```shell
2
2
```

### 加载其他文件变量及数组

在一个Shell程序中可以指定包含外部的其他Shell脚本程序。

这样可以很方便的封装一些公用的代码作为一个独立的文件。

Shell 文件包含的语法格式如下：

```shell
. <filename>
source <filename>
```

定义两个shell文件分别为： test1.sh、test2.sh

1. 在test1中定义一个变量 `arr=(linux hadoop shell)`
2. 在test2中对 `arr` 进行循环打印输出

第一步: vim test1.sh

```shell
#!/bin/bash
arr=(linux hadoop shell)
```

第二步: vim test2.sh

```shell
#!/bin/bash
source /class_0618/LYZ/test1.sh # 加载test1.sh 的文件内容
for var in "${my_arr[@]}"
do
echo $var
done
```

优点 :

- 数据源和业务处理分离
- 复用代码扩展性更强

缺点：

- 文件间具有依赖性，文件丢失会导致其他文件报错
